//# Atividade_2
//**Under Construction** it solves the challenge given by https://br.spoj.com/problems/ET/
//

#include <string>
#include <iostream>
#include <vector>
using namespace std;

//Get the initial variable.
char getInitial(){

	string initial;

	getline(cin, initial);

	return initial.at(0);

}

//Get the non-terminal variables from the grammar
string getNonTerminals(){

	string NonTerminals;

	getline(cin, NonTerminals);

	return NonTerminals;

}

//Get the terminal variables from the grammar
string getTerminals(){

	string Terminals;

	getline(cin, Terminals);

	return Terminals;

}

//Read the entries until a stop value is read.
//stop is the parameter that stops the reading.
vector<string> readUntilStop(string stop){

	vector<string> instances;

	string line;

	while (getline(cin, line)){

		if (line.compare(stop) == 0)
			break;

		else
			instances.push_back(line);

	}

	return instances;
}

//Get all the rules of the Grammar
vector<string> getRules(){

	string stop = "# -> #";

	return readUntilStop(stop);

}

//Read the words to be tested.
vector<string> getTestWords(){

	string stop = "#";

	return  readUntilStop(stop);

}

//Breaks the string that contains the rule, and delimite the right side from the left side.
//rule contains the rule without identification of wich is left or right.
pair<string, string> getEachRuleSide(string rule){

	pair<string, string> sided_rule;

	string left, right;
	string delimiter = " -> ";

	size_t pos = 0;
	pos = rule.find(delimiter);
	left = rule.substr(0, pos);
	right = rule.erase(0, pos + delimiter.length());

	return make_pair(left, right);

}

//Check if a given char segment is on the string
//longest = the string where the segment might be.
// segment is the char segment to be found.
bool checkIfInString(string longest, char segment){

	return longest.find(segment) != std::string::npos;

}


//Literally turns a single char into a string of size one.
string TurnCharToString(char c){

	return string(1, c);

}

//returns zero if a string is equal to another.
int compareTwoStrings(string a, string b){

	return a.compare(b);

}

//For each letter, from left to right, recursively call all the rules that contain that letter, if not-terminal.
bool makeDerivations(string word, string target, int derivation_number, vector<pair<string, string>> rules, string NonTerminals){

	if (derivation_number == (2 * target.length()) - 1 && word.compare(target) == 0)
		return true;

	else if (derivation_number == (2 * target.length()) - 1 && word.compare(target) != 0)
		return false;

	int i = 0;

	bool found = false;

	//We seek the Non-terminal letter most at left to apply some rule, so it is made a verification to see if we are dealing with a terminal or non-terminal.
	while (i < word.length()){

		//Check if terminal or non terminal.
		if (checkIfInString(NonTerminals, word.at(i))){

			//For each rule, seeks for the letter. But only none of the nodes found a word that matches the target.
			for (int j = 0; j < rules.size() && !found; j++)
				//Check if the selected rule is generated by a letter equal to the selected "most at left" letter.
				if (compareTwoStrings(TurnCharToString(word.at(i)), rules.at(j).first) == 0)
					//Fowards the process with the new word.
					if (makeDerivations(word.replace(i, 1, rules.at(j).second), target, derivation_number + 1, rules, NonTerminals))
						found = true;


			//It stops the execution on the first nonterminal letter.
			break;
		}

		i++;
	}

	return found;

}

vector<pair<string, string>> getEachSidedRule(vector<string> rules){

	vector<pair<string, string>> each_rule;

	for (int i = 0; i < rules.size(); i++)
		each_rule.push_back(getEachRuleSide(rules.at(i)));

	return each_rule;
}

void readInstances(int instancia, char initial){

	string NonTerminals = getNonTerminals();
	string Terminals = getTerminals();
	vector<string> rules = getRules();
	vector<string> test_words = getTestWords();

	vector<pair<string, string>> each_rule = getEachSidedRule(rules);

	cout << "Instancia " << instancia << endl;

	//For each word of  rule made by S, calls makeDerivation
	for (int i = 0; i < test_words.size(); i++){

		bool found = false;

		for (int j = 0; j < rules.size() && !found; j++)
			if (each_rule.at(j).first.compare(string(1, initial)) == 0)
				//cout << " Rule: " << rules.at(j).first << " -> " << rules.at(j).second << " Resultante: " << word.replace(i, rules.at(j).second.length(), rules.at(j).second)<<endl;
				if (makeDerivations(each_rule.at(j).second, test_words.at(i), 1, each_rule, NonTerminals))
					found = true;

		if (found)
			cout << test_words.at(i) << " e uma palavra valida" << endl;
		else
			cout << test_words.at(i) << " nao e uma palavra valida" << endl;

	}

	cout << endl;

}

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
int main(){

	int x = 1;

	string initial;

	while (getline(cin, initial)){

		readInstances(x, initial.at(0));
		x++;

	}

	system("PAUSE");

	return 0;
}
